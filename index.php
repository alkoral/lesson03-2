<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Домашнее задание к лекции 3.2 «Наследование и интерфейсы»</title>
  <style>
    body {
    font-size: 16px;
    font-family: "Trebuchet MS", Helvetica, sans-serif;
    }
    h1, h2 {
    font-size: 22px;
    font-weight: 700;
    color: blue;
    }
    article {
    display: block;
    position: relative;
    margin: 0 auto;   
    width: 800px;
    }
    p {
    font-family: "Arial", Helvetica, sans-serif;
    font-size: 17px;      
    }

  </style>
</head>
<body>

<article>
<h1>Формулировки и пояснения</h1>
<p><strong>Наследование</strong> (наряду с инкапсуляцией и полиморфизмом) часто называют одним из трех фундаментальных принципов объектно-ориентированного программирования в PHP.</p>
<p>При помощи механизма наследования можно создать новый (дочерний) класс на основе уже существующего (родительского) класса, передав «дочке» базовый набор свойств и методов. Причем полученные по «наследству» свойства и функционал могут оставаться в дочернем классе в первоначальном виде, но могут быть переопределены и под конкретные требования нового класса.</p>
<p>Естественно, дочерний класс (подкласс) может быть расширен собственными свойствами и методами, которых нет у «родителя» (у суперкласса).</p>
<p>Благодаря наследованию облегчается работа по внесению изменений в одинаковые свойства и методы, перешедшие «дочкам» от «родителя». При таком подходе достаточно внести правку в родительский класс вместо того, чтобы править все дочерние. Это гарантирует не только экономию времени, но и резко сужает «поле», где можно допустить ошибки в коде.</p>
<p>Суперкласс может иметь сколь угодно много подклассов, а те, в свою очередь, выступать родительскими классами для новых «дочек» (или «внучек» для базового класса). Однако у одного подкласса может быть только один «родитель». В результате сложная иерархия классов и подклассов схематично может показаться схожей с видом генеалогического древа человека.</p>
<p>Механизм наследования избавляет программистов от дублирования кода для объектов, имеющих схожие «черты». Благодаря тому, что нет нужды каждый раз «с нуля» определять методы для новых классов, экономится время на написание кода, а сам код становится значительно короче и понятнее.</p>

<p><strong>Полиморфизм</strong>, еще один базовый принцип ООП, вытекает из понятия «наследование». Как уже говорилось выше, при наследовании дочерним классом функционала родительского класса существует возможность переопределять методы, задавая им разное поведение. Если говорить коротко, то в объектно-ориентированном программировании PHP переопределение и есть полиморфизм, или множественность форм поведения класса при использовании общего интерфейса.</p>
<p>Таким образом, при вызове одного и того же метода суперкласса из различных подклассов можно получить совершенно различный результат этого действия. Как пример проявления полиморфизма мне нравится сравнение одного из родительских методов (интерфейса) с обычной кнопкой. Мы знаем, что при нажатии кнопки должно что-то произойти, но что именно – зависит от того, где установлена кнопка, к какой схеме или прибору (читай, подклассу) она подключена.</p>
<p>Стоит ли говорить о том, что полиморфизм, как и другие «киты», на которых стоит ООП, позволяет писать более краткий и понятный код, избегая дублирования одинаковых функций для схожих классов и объектов и сокращая «простор» для случайных ошибок.</p>
<p>Остается только с сожалением добавить, что воспользоваться на практике всеми преимуществами инкапсуляции, наследования и полиморфизма можно лишь при глубоком понимании сущности ООП, что для начинающих программистов является, на мой взгляд, одной из самых сложных задач при изучении PHP.</p>

<p><strong>Интерфейсы и абстрактные классы</strong> похожи друг на друга, однако интерфейсы не могут содержать в себе свойства – допустимы только абстрактные методы (ну, и константы). При этом у интерфейсов нет функционала, они не содержат реализацию методов (проще говоря, кода), а только определяют их, или, как говорят, представляют собой «соглашение» между разными классами. Причем все методы у интерфейса – только публичные.</p>
<p>Если абстрактные классы могут наследоваться от других классов (extends), то интерфейсы – имплементируются в классы (implements), или реализуются. Из этого следует, что наследовать можно только один класс, а реализовывать – сколько угодно интерфейсов.</p>
<p>Чаще всего интерфейсы представляют собой небольшой фрагмент абстрактного класса, выполняющий одну конкретную задачу или их минимальный набор. При помощи нескольких «узконаправленных» интерфейсов можно, словно в конструкторе, собирать целые классы, «заточенные» под конкретные задачи, что делает код более гибким и менее ошибкоёмким (если можно так сказать).</p>

<h2>Ссылки:</h2>
<ul>
  <li><a href="classes.php">Результат добавления суперкласса и интерфейсов для всех объектов</a></li>
  <li><a href="../lesson03-1/index.php">Домашнее задание к лекции 3.1 «Классы и объекты»</a></li>
</ul>
<br>
</article>
</body>
</html>